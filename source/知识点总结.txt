1. React中函数组件和类组件的区别

共同点： 
    组件名称必须以大写字母开头

    组件的返回值只能有一个根元素    

    无论是使用函数或是类来声明一个组件，它决不能修改它自己的 props。

    所有 React 组件都必须是纯函数，并禁止修改其自身 props 。

    React是单项数据流，父组件改变了属性，那么子组件视图会更新。

    属性 props 是外界传递过来的，状态 state 是组件本身的，状态可以在组件中任意修改

    组件的属性和状态改变都会更新视图。    


区别：

　　函数组件的性能比类组件的性能要高，

    因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。

　　为了提高性能，尽量使用函数组件。

　　函数组件没有this,没有生命周期，没有状态state,

　　类组件有this,有生命周期，有状态state。    




2. React中的Redux

   Redux 中的 三个概念 store、action、reducer

   Redux在使用React开发应用时，起到什么作用————状态集中管理    

                   (监听器改变状态)                 
   Action(事件) -------------------> Reducer(监听器：改变状态)  ------------------->  Store(状态树)
                                            ↑
                                            |                                            |
                                            |                                            |    
                                            |                                            |    
                                            |                                            |
                                            |                                            |
                                            |                                            |   
                                            |                                            ↓                                                                                         
                                         Action <--------------------------------- view(重新选择)    
                                                                       (Dispach)     
                                    

action：是事件，它本质上是JavaScript的普通对象，它描述的是“发生了什么”。action由type：string和其他构成。

reducer是一个监听器，只有它可以改变状态。是一个纯函数，它不能修改state,所以必须是生成一个新的state。在default情况下，必须但会旧的state。

store是一个类似数据库的存储（或者可以叫做状态树），需要设计自己的数据结构来在状态树中存储自己的数据。




3. for in 和 for of

for-in 循环和for-of循环两种增强型循环。其中，for-in是ES5标准，遍历的是key（可遍历对象、数组或字符串的key）；for-of是ES6标准，遍历的是value（可遍历对象、数组或字符串的value）。

所以for-in更适合遍历对象，通常是建议不要使用for-in遍历数组

for-of可以简单、正确地遍历数组

3.与forEach()不同的是，它可以正确响应break、continue和return语句。


4. 2个窗口之间的通讯方式
  https://blog.csdn.net/chenzihong123/article/details/103805368
 （1）localstorage
    一个窗口更新localStorage，另一个窗口监听window对象的”storage”事件，来实现通信。(localStorage需要同源窗口才能共享，即协议，域名，端口一致)
 （2) WebSocket
    所有的WebSocket都监听同一个服务器地址，利用send发送消息，利用onmessage获取消息的变化，不仅能窗口，还能跨浏览器，兼容性最佳，只是需要消耗点服务器资源。
  (3) window.postMessage() 
    window.postMessage()方法可以安全地实现Window对象之间的跨域通信。例如，在一个页面和它生成的弹出窗口之间，或者是页面和嵌入其中的iframe之间。   
  (4) 使用window.name  
    浏览器窗口有window.name属性，这个属性的特点是：只要在同一窗口中，无论是否同源，不同网页的window.name属性都是共享的。
    优点：window.name数据容量大（相比片段识别符）
    缺点：（1）必须同一窗口；（2）必须监听窗口window.name属性的变化，影响网页性能；    

5.使用<link>与 @import 的区别
  (1).从属关系区别
    @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。        
  (2).加载顺序区别 ；@import引入的 CSS 将在页面加载完毕后被加载。  
  (3).兼容性区别
    @import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。
  (4).DOM可控性区别
    可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。
  (5).权重区别(该项有争议，下文将详解)
    link引入的样式权重大于@import引入的样式。    
    
6.浏览器的渲染机制 
  (1). 解析HTML，生成DOM树（DOM） 
  (2). 解析CSS，生成CSSOM树（CSSOM） 
  (3). 将DOM和CSSOM合并，生成渲染树（Render-Tree） 
  (4). 计算渲染树的布局（Layout） 
  (5). 将布局渲染到屏幕上（Paint)


7.图片的懒加载如何实现
  https://blog.csdn.net/weixin_42609477/article/details/108230259
  懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。
  首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-src属性中，
  当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。


8.px em rem 的区别
  
  Px表示“绝对尺寸”（并非真正的绝对）， 像素px 是相对于显示器屏幕分辨率而言的。
  
  （1）.IE无法调整那些使用px 作为单位的字体大小；
  （2）.外国的大部分网站能够调整的原因在于其使用了 em 或 rem 作为字体单位；
  （3）.Firefox 能够调整px 和 em , rem ,但是 96%以上的中国网民 使用IE浏览器（或者内核）。

  em 是相对长度单位。相对于当前对象内文本的字体尺寸。 如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸
  （1）. em的值不是固定的
   (2). em会继承父级元素的字体大小


  rem也表示相对尺寸，其参考对象为根元素<html>的font-size，因此只需要确定这一个font-size。

9. catchstorage 

10.计算用户的有效停留时间

 beforeunload事件可计算出用户停留在页面的时间具体代码如下：
  ``` javascript 
  
      var start;

      var end;

      var total_time = 0;
      start = new Date();//用户进入时间
      $(window).bind('beforeunload', function (e) {
          end = new Date(); //用户退出时间
          total_time = end.getTime() - start.getTime();
          total_time = Math.ceil(total_time / 1000); //取的是秒并且化整用户停留时间
          $.ajax({
            type: 'POST',
          async: false, //同步提交
          url: “”,
          data://给后台的参数
        });
    });
  ```  

11.节流和防抖

  PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。


  防抖：在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。

  手写一防抖：

     ```javascript

        function debounce(fn , wait){
            var timer = null; 

            return function(){

               var context = this

               var args = arguments 

               if( timer ) {

                  clearTimeout(timer); 

                  timer = null;

               }
               timer = setTimeout (function(){
                  fn.apply( context, args )
               }, wait)
            }
        }

     ```



  
  节流：防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。

  手写一个节流：

    ```javascript
       
       function throttle(fn , gapTime){           
          let lastTime = null; 

          return function(){

            let nowTime = + new Date()

            if( nowTime - lastTime  > gapTime || !lastTime ){    // 如果 现在的时间 减去 上一次触发的时间 大于 规定节流的时间间隔，或者是第一次 触发则调用一次函数。

                fn();

                lastTime = nowTime 
            }
          } 

       }

      // 被节流的目标函数

      let fn = () =>{
        console.log('触发了该函数')
      }

      // 用setInterval 模拟实际工作中触发节流

      setInterval( throttle(fn, 1000), 10) 

    ```


  ```javascript

    /**
    * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait
    *
    * @param  {function}   func      回调函数
    * @param  {number}     wait      表示时间窗口的间隔
    * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。
    *                                如果想忽略结尾函数的调用，传入{trailing: false}
    *                                两者不能共存，否则函数不能执行
    * @return {function}             返回客户调用函数

    */

    function throttle(fn, gapTime){

        let lastTime = null; 

        return function(){

            let nowTime = +new Date()

            if( nowTime - lastTime > gapTime || !lastTime ){ // 如果现在的时间 减去上一次触发的时间大于 规定节流的时间间隔，或者是第一次触发则调用一次函数
                fn();

                lastTime = nowTime
            } 
        }
    }



// 被节流的目标函数

    let fn = () =>{
      console.log('触发了该函数')
    }

// 用setInterval 模拟实际工作中触发节流


  setInterval( throttle(fn, 1000),10 )
  ```

12.vue 子组件与子组件之前的传值

   （1）.子组件向子组件传递数据

    Vue 没有直接子对子传参的方法，建议将需要传递数据的子组件，都合并为一个组件。如果一定需要子对子传参，可以先从传到父组件，再传到子组件。

    为了便于开发，Vue 推出了一个状态管理工具 Vuex，可以很方便实现组件之间的参数传递

13. vue父组建向子组件传值

    (1). 如果需要从父组件获取logo 的值，就需要使用 props: ["logo"]

14.子组件向父组件传递数据
    （1）. 子组建主要通过事件传递给父组件

    ``` vue

    //子组建部分

      <template>
        <input v-model="username" @change="setUser"/>    
      <template/>

      <script>  
          export default{
            name: 'login', 
            data(){
              return{
                username: ''
              }
            },
            methods:{
              setUser:function (){
                this.$emit('transferUser', this.username)
              }
            }
          }
      <script/>

   // 父组建部分


    <template>
      <div id="app">
        <InputDiv @transferUser="getUser"/>  
      <div>   
    <template/>  

    <script>
      export default{
        name: 'app', 
        data(){
          return{
            user: ''
          }
        },
        methods:{
          getUser( msg ){
            this.user = msg
          }
        }
      }
    <script/>
    ```

14.margin 合并现象的解决方案
  1.给box2加上一层父级元素并加上overflow:hidden;

  2.给两个都加一层父级再加bfc

  3.给父盒子设置内边距

  4.父盒子:position:fixed

15. css中min-width 和max-width， width与他们之间的区别联系

  css中，min-width是用来限制元素的最小宽度，max-width用来限制元素的最大宽度，也就是说当元素的width大于max-width,或者小于min-width。就被它们的值所代替，尤其适用于网站的自适应。


16. react 虚拟Dom 的diff

https://zhuanlan.zhihu.com/p/20346379

1.传统diff算法
计算两颗树形结构差异的最优解一直是一个复杂且值得研究的问题，传统的diff算法，需要遍历整棵树的节点然后进行比较，是一个深度递归的过程，运算复杂度常常是O(n^3)，这样的低效率在react中肯定是不能容忍的，那么react对于diff算法进行了哪些优化呢？

2.react diff的优化策略

(1).tree diff
    DOM节点跨层级的操作不做优化，因为很少这么做，这是针对的tree层级的策略；
(2).component diff    
    对于同一个类的组件，会生成相似的树形结构，对于不同类的组件，生成不同的树形结构，这是针对conponent层级的策略；
(3).element diff
    对于同一级的子节点，拥有同层唯一的key值，来做删除、插入、移动的操作，这是针对element层级的策略；


React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；

React 通过分层求异的策略，对 tree diff 进行算法优化；

React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；

React 通过设置唯一 key的策略，对 element diff 进行算法优化；

建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；

建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。


17.TCP 的3次握手4次挥手

第一次握手

客户主动（active open）去connect服务器，并且发送SYN 假设序列号为J,
服务器是被动打开(passive open)

第二次握手

服务器在收到SYN后，它会发送一个SYN以及一个ACK（应答）给客户，
ACK的序列号是 J+1表示是给SYN J的应答，新发送的SYN K 序列号是K

第三次握手

客户在收到新SYN K, ACK J+1 后，也回应ACK K+1 以表示收到了，
然后两边就可以开始数据发送数据了


【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？
来
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用同步的。
但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。
所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。
Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。
Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。
如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。
MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。
如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

【问题3】为什么不能用两次握手进行连接？

答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，
S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。
可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。
在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。
而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。
服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，
服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。
若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

18.vue router，的实现原理

前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式

hash 模式
history 模式

www.test.com/##/ 就是 Hash URL，当 ## 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面。




19. 跨域

跨域前端解决方案及原理

1.JSONP 

  JSONP 的原理很简单，就是利用<script> 标签没有跨域限制的漏洞。 通过<script>标签指向一个需要访问的地址并提供一个回调函数来接收数据。
  
  JSONP 使用简单且兼容性不错，但是只限于 get 请求。



2.CORS

  CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。

  浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

  服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。



3.document.domain

  该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。

  只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域


4.postMessage

  这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息



20. redux 是什么？

    Redux 是一个 javaScript 应用设计的可预测的状态容器。  
    
    它解决了以下问题： 

      1.跨层级的组件之间的数据传递变得很容易

      2.所有对状态的改变都需要 Dispach , 使得整个数据的改变可追踪，方便排查问题。

    但是它也有缺点

      概念偏多，理解起来不容易

      样板代码太多



21.调用setState 之后发生了什么？

  1. 在setState的时候，React会为当前节点创建一个 updateQueue 的更新队列。

  2. 然后会触发 reconciliation(和谐) 过程,在这个过程中，会使用名为 Fiber 的调度算法，开始生成新的 Fiber 树，
  Fiber 算法的最大特点是可以做到异步可中断的执行。

  3.然后React Scheduler(调度器) 会根据优先级高低，先执行优先级高的节点，具体是执行 doWork 方法。

  4.在 dowork 方法中, React会执行一遍 updataQueue 中的方法获得新节点，然后对比新旧节点，为老节点打上 更新、插入、替换等标签。

  5. 当前节点 doWork 完成后，会执行 performUnitOfWork 方法获得新节点，然后再重复上面的过程。

  6. 当所有节点都 dowork 完成后，会触发 commitRoot 方法， react进入 commit阶段。

  7.在commit 阶段中， React会根据前面为各个节点打的Tag， 一次性更新整个dom 元素


22. xss 攻击

  如何攻击

  XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。



  如何防御

  最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义


23. CSRF攻击  

  简单点说，CSRF 就是利用用户的登录态发起恶意请求。

  跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，
  
  通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。
  
  [1] 跟跨網站指令碼（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。


  如何攻击

  假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口


  如何防御

  防范 CSRF 可以遵循以下几种规则：

  Get 请求不对数据进行修改
  不让第三方网站访问到用户 Cookie
  阻止第三方网站请求接口
  请求时附带验证信息，比如验证码或者 token

 24. http 状态

    200：请求已经成功，请求所希望的相应或数据体将随此相应返回

    201 (已创建)请求成功并且服务器创建了新的资源

    302：请求的资源面临从不同的URI响应请求，由于3这样的重定向时临时的，
    客户端应当继续向原有的地址发送以后的请求只有在Cache-control或Exception中进行了指定的情况下，这个响应才是可缓存的。

    304：如果客户端发送了一个带有条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，
    则服务器应当返回这个状态码，304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。

    400：(错误请求)  服务器不理解请求的语法。

    401：(未授权)  请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。

    403：服务器已经理解请求，但是拒绝了执行它

    404： （未找到） 服务器找不到请求的网页。

    406: '请求的格式不可得。',   

    410: '请求的资源被永久删除，且不会再得到的。',   

    500：（服务器内部错误） 服务器遇到错误，无法完成请求。

    502: '网关错误。',

    503: '服务不可用，服务器暂时过载或维护。',

    504: '网关超时。',

  25.Effect Hook
    之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。
    我们统一把这些操作称为“副作用”，或者简称为“作用”。useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。
    它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。
    （我们会在使用 Effect Hook 里展示对比 useEffect 和这些方法的例子。）

  26.call 和 apply 的区别 ？ 那个性能更好？

    call 可以接收一个参数列表，apply 只接受一个参数数组。

    1.call 和 apply 都是 function 类原型上的方法； 每一个函数作为function 的实例都能调用这两方法；
    
     这两个方法执行的目的都是用来改变函数中的this指向的，让函数执行并且能改变this指向。

    2.区别：

      1、call 传参的时候要求我们给函数传参是一个个地传，而apply 的要传的参数是以一个数组保存起来；

      2、一样改变 this 的还有 bind , bind并没有立即执行函数，只是预先把处理改变函数中的 this 

      3、call 的性能要比 apply 好一些（尤其是传递给函数的参数超过三个的时候 ） 
       
        let arr =[10, 20, 30], 

        obj={}

        function fn(x, y, z){

        }

        fn.apply(obj, arr)

        fn.call(obj, ...arr )  // 基于ES6 的展开 运算符号也可以

      4、使用方法

        call(thisObj, arg1, arg2, arg3, arg4);

        apply(thisObj, [args]);

        thisObj：call和apply第一个参数是一样的，该参数将替代Function类里面的this对象。
        
        arg1,arg2....：是一个个的参数，
        args：一个数组或类数组，是一个参数列表。


  27、前端开发的设计模式有哪些

  1、模块模式；2、构造函数模式；3、工厂模式；4、混合模；5、单例模式；6、订阅发布模式等等。

  前端常见的设计模式有以下几种：单例模式、工厂模式、构造函数模式、原型模式、混合模式、动态原型模式这几种，接下来我们一起了解一下这些模式具体的情况。


1.单例模式

    又称为单体模式。保证一个类只有一个实例，并提供一个访问它的全局访问点。

    第二次使用同一个类创建新对象的时候，应该得到第一次创建的对象完全相同的对象。


    通过静态属性创建单例

    ```javascript 

    class Person{
        static instance = null; //静态属性，不会被实例继承，由类直接调用
        constructor(name){
            if(Person.instance){
                return Person.instance;
            }
            Person.instance = this;
            this.name = name;
        }
    }
    ```

    通过函数创建单例


    ```javascript

    let instance;
    function createInstance(...arg){
        if(!instance){
            instance = new Game(...arg);
        }
        return instance;
    }

    ```

    ==优点：==实现代码复用性，封装良好，抽象逻辑

    ==缺点：==单例模式扩展性不强

2.工厂模式

```javascript 

    function createPerson(name, age) {
        var obj = {};
        obj.name = name;
        obj.age = age;
        obj.writeJs = function () {
            console.log(this.name + 'write js');
        }
        return obj;
    }

    var p1 = createPerson('mengzhe' , 26);
    p1.writeJs();

    var p2 = createPerson('iceman' , 25);
    p2.writeJs();

```
==优点：==实现代码复用性，封装良好，抽象逻辑

==缺点：==不能识别对象的类型，全部是Object


3.构造函数模式

```javascript 

function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
       alert(this.name);
    };
}
const scater = new Person("scater", 29, "web前端");
console.log(scater instanceof Person)// true

```

首字母大写
使用new创建对象

==优点：==能够识别对象

==缺点：==每次创建实例的时候都要重新创建一次方法


4.混合模式（原型模式 + 构造函数模式

  创建自定义类型的最常见方式。

  构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。

  ```javascript 

  function Person(name, age, job){
      this.name = name;
      this.age = age;
      this.job = job;
      this.friends = ["Shelby", "Court"];
  }
  Person.prototype = {
      constructor : Person,
      sayName : function(){
          alert(this.name);
      }
  }
  var person1 = new Person("Nicholas", 29, "Software Engineer");
  var person2 = new Person("Greg", 27, "Doctor");
  person1.friends.push("Van");
  alert(person1.friends); //"Shelby,Count,Van"
  alert(person2.friends); //"Shelby,Count"
  alert(person1.friends === person2.friends); //false
  alert(person1.sayName === person2.sayName); //true

  ```
  ==优点：==每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。
19. 跨域的后端解决方案


20.从输入url到浏览器显示页面发生了什么


  1、输入网址

  当你开始输入网址比如www.cnblogs.com时浏览器就可以在书签或者历史记录里面去搜索相关的网址推荐给你


  2、浏览器查找域名的IP地址



  3、建立TCP链接



  4、浏览器向WEB服务器发起Http请求



  5、服务器端处理



  6、关闭TCP链接
  
   为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。
   与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。


   console.log('1');
    setTimeout(function () {
      console.log('2');
      new Promise(function (resolve) {
        console.log('3');
        resolve();
      }).then(function () {
        console.log('4')
      })
    },0)
    new Promise(function (resolve) {
      console.log('5');
      resolve();
    }).then(function () {
      console.log('6')
    })

    setTimeout(function () {
      console.log('7');
      new Promise(function (resolve) {
        console.log('8');
        resolve();
      }).then(function () {
        console.log('9')
      })
      console.log('10')
    },0)
    console.log('11')
